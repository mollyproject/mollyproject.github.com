Writing an application
======================

A Molly application is a Python package with a certain layout.

Normally, you'll see:

.. code-block:: none

   myapp/
   ├ templates/
   │   └ myapp/
   │       ├ base.html
   │       ├ index.html
   │       └ [...]
   ├ templatetags/
   │   ├ __init__.py
   │   └ myapp.py
   ├ __init__.py
   ├ admin.py
   ├ forms.py
   ├ models.py
   ├ providers.py
   ├ urls.py
   └ views.py

Most of these follow the Django conventions, so if you're unfamiliar you
should consult the Django documentation.

The flow of a request
---------------------

Django despatches an incoming request to the callback given in a urlconf
which, in Molly, is a class object. Calling a class object is mapped to
calling it's ``__new__`` method. Ordinarily, this returns an instance of that
class, but in Molly it returns the response. Specifically:

.. class:: FooView

   .. classmethod:: __new__(request, *args, **kwargs):

      :param request: The request from the client to be processed.
      :type request: :class:`~django.http.HttpRequest`
      :rtype: :class:`~django.http.HttpResponse`

Unless overridden, the method called is
:meth:`molly.utils.views.BaseView.__new__`. This performs the following steps:

 * Checks there is a handler available for the HTTP method specified. If not,
   it immediately returns a ``405 Method Not Acceptable`` response.
 * Calls ``cls.initial_context(request, *args, **kwargs)``, which can provide
   context for all method handlers. A developer can use this to factor out
   code common between each of the handlers.
 * Evaluates the breadcrumbs and adds the resulting information to the
   context.
 * Calls the relevent handler, the name of which is determined by appending
   the method name to ``handle_``, e.g. ``handle_GET``. The handler is passed
   the request, context and any positional and keyword arguments.
 * The handler will update the context and perform any required actions as
   necessary.
 * The handler will generally return a :class:`~django.http.HttpResponse`
   subclass directly, or call the :meth:`~molly.utils.views.BaseView.render`
   method on :class:`~molly.utils.views.BaseView`.
 * In the latter case, :meth:`~molly.utils.views.BaseView.render` will
   determine which format to serialize to using a ``format`` query parameter
   or content negotiation, and despatch to a format-specific rendering method
   (e.g. :meth:`~molly.utils.views.BaseView.render_html`).
 * The renderer will return a :class:`~django.http.HttpResponse` object, which
   will then be passed back up the callstack to Django to be sent back to the
   client.

Views
-----

Molly uses class-based views to provide greater extensibility than
function-based views.

.. note::

   More information about Molly's use of class-based views can be found
   :doc:`here <class_based_views>`.

A basic view looks a little like this::

    from django.shortcuts import get_object_or_404
    from django.http import HttpResponseForbidden

    from molly.utils.views import BaseView
    from molly.utils.breadcrumbs import *
    from molly.http import HttpResponseSeeOther

    from .models import Thing
    from .forms import ThingUpdateForm

    class ThingDetailView(BaseView):
        def get_metadata(cls, request, thing_id):
            thing = get_object_or_404(Thing, id = thing_id)
            return {
                'title': thing.title,
                'additional': 'A %s thing with a %s leg.' % (thing.colour, thing.leg_type),
            }

        @BreadcrumbFactory
        def breadcrumb(cls, request, context, thing_id):
            return Breadcrumb(
                cls.conf.local_name,
                lazy_parent('things:index'),
                thing.title,
                lazy_reverse('things:detail', args=[thing_id]),
            )

        def initial_context(cls, request, thing_id):
            thing = get_object_or_404(Thing, id = thing_id)
            return {
                'thing': thing,
                'form': ThingUpdateForm(request.POST or None, instance = thing),
            }

        def handle_GET(cls, request, context, thing_id):
            return cls.render(request, context, 'things/thing_detail')

        def handle_POST(cls, request, context, thing_id):
            if not getattr(cls.conf, 'allow_edits', False):
                return HttpResponseForbidden()

            if context['form'].is_valid():
                context['form'].save()
                return HttpResponseSeeOther(reverse('things:detail'))
            else:
                return cls.handle_GET(request, context, thing_id)

For a 'basic' view, there's quite a lot going on here. Be [TODO]

